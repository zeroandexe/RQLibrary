#pragma once

/*
	这里是抽象语法树的全局声明区,也是作为运算符的特征代表值
*/

enum {
	M_SYMBOL_TOKEN_NULL = 0,		//NULL
	M_SYMBOL_TOKEN_VAR,				//var

	//函数特征
	M_SYMBOL_TOKEN_FUN,				//function

	//赋值操作
	M_SYMBOL_TOKEN_EQUAL,			//=
	M_SYMBOL_TOKEN_ADD_EQUAL,		//+=
	M_SYMBOL_TOKEN_SUB_EQUAL,		//-=
	M_SYMBOL_TOKEN_MULIT_EQUAL,		//*=
	M_SYMBOL_TOKEN_DIV_EQUAL,		///=
	M_SYMBOL_TOKEN_MOLD_EQUAL,		// %=

	//四则运算
	M_SYMBOL_TOKEN_ADD,				//+
	M_SYMBOL_TOKEN_SUB,				//-
	M_SYMBOL_TOKEN_MULIT,			//*
	M_SYMBOL_TOKEN_DIV,				///
	M_SYMBOL_TOKEN_MOLD,			// %

	//比较运算
	M_SYMBOL_TOKEN_MORE,			//>
	M_SYMBOL_TOKEN_LESS,			//<
	M_SYMBOL_TOKEN_LESS_EQUAL,		//<=
	M_SYMBOL_TOKEN_MORE_EQUAL,		//>=
	M_SYMBOL_TOKEN_EQUAL_EQUAL,		//==
	M_SYMBOL_TOKEN_NON_EQUAL,		//!=

	//逻辑运算
	M_SYMBOL_TOKEN_NON,				//!
	M_SYMBOL_TOKEN_OR,				//||
	M_SYMBOL_TOKEN_AND,				//&&

	//特殊处理符
	M_SYMBOL_TOKEN_COMMA,						//,
	M_SYMBOL_TOKEN_SMALL_LEFT_PARENTHESES,		//(
	M_SYMBOL_TOKEN_SMALL_RIGHT_PARENTHESES,		//)
	M_SYMBOL_TOKEN_SMALL_PARENTHESES,			//()
	M_SYMBOL_TOKEN_BIG_LEFT_PARENTHESES,		//{
	M_SYMBOL_TOKEN_BIG_RIGHT_PARENTHESES,		//}

	//以下是变体符
	M_SYMBOL_TOKEN_AND_TO_EQUAL,	//该'='运算符号是and运算变体
	M_SYMBOL_TOKEN_OR_TO_EQUAL,		//该'='运算符是or运算符变体

	M_SYMBOL_TOKEN_POINT,			//定义小数点
	M_SYMBOL_TOKEN_AT,				//定义@，用于全局变量引用
	//----其他辅助运算符（内部使用不交与外界和脚本）
	M_SYMBOL_TOKEN_OTHER_SWAP,
	M_SYMBOL_TOKEN_TOTAL,			//符号所用位的总数
};


//符号优先级处理，数值越大则优先级越高，枚举命名越小优先级越低
//由于变量不参与运算符处理，所以变量的优先级为0

enum {
	M_SYMBOL_PRIORITY_NULL = 0,			//NULL
	//添加@
	M_SYMBOL_PRIORITY_AT,				//@	：提供环境变量引用
	M_SYMBOL_PRIORITY_VAR,				//var

	M_SYMBOL_PRIORITY_ADJUST,			//调整阶段，比如用于小数组装，成员变量调用
	M_SYMBOL_PRIORITY_ZERO,
	M_SYMBOL_PRIORITY_ONE,
	M_SYMBOL_PRIORITY_TWO,
	M_SYMBOL_PRIORITY_THREE,
	M_SYMBOL_PRIORITY_FOUR,
	M_SYMBOL_PRIORITY_FIVE,
	M_SYMBOL_PRIORITY_SIX,
	M_SYMBOL_PRIORITY_SEVEN,
	M_SYMBOL_PRIORITY_EIGHT,
	M_SYMBOL_PRIORITY_NINE,
	M_SYMBOL_PRIORITY_TEN,
	M_SYMBOL_PRIORITY_TEN_ONE,
	M_SYMBOL_PRIORITY_MAX,


	//添加逗号运算符
	M_SYMBOL_PRIORITY_COMMA = M_SYMBOL_PRIORITY_ONE,			//	,

	//赋值操作
	M_SYMBOL_PRIORITY_EQUAL = M_SYMBOL_PRIORITY_TWO,			//	=
	M_SYMBOL_PRIORITY_SUB_EQUAL = M_SYMBOL_PRIORITY_TWO,		//	-=
	M_SYMBOL_PRIORITY_DIV_EQUAL = M_SYMBOL_PRIORITY_TWO,		//	/=
	M_SYMBOL_PRIORITY_MULIT_EQUAL = M_SYMBOL_PRIORITY_TWO,		//	*=
	M_SYMBOL_PRIORITY_ADD_EQUAL = M_SYMBOL_PRIORITY_TWO,		//	+=
	M_SYMBOL_PRIORITY_MOLD_EQUAL = M_SYMBOL_PRIORITY_TWO,		//	%=


																//函数运算符


	//逻辑操作
	M_SYMBOL_PRIORITY_AND = M_SYMBOL_PRIORITY_THREE,				//	&&
	M_SYMBOL_PRIORITY_OR = M_SYMBOL_PRIORITY_THREE,					//	||
	M_SYMBOL_PRIORITY_NON = M_SYMBOL_PRIORITY_SEVEN,				//	!		取非运算符优先级元素只能有这一个

	//比较
	M_SYMBOL_PRIORITY_LESS = M_SYMBOL_PRIORITY_FOUR,			//	<
	M_SYMBOL_PRIORITY_MORE = M_SYMBOL_PRIORITY_FOUR,			//	>
	M_SYMBOL_PRIORITY_LESS_EQUAL = M_SYMBOL_PRIORITY_FOUR,		//	<=
	M_SYMBOL_PRIORITY_MORE_EQUAL = M_SYMBOL_PRIORITY_FOUR,		//	>=
	M_SYMBOL_PRIORITY_EQUAL_EQUAL = M_SYMBOL_PRIORITY_FOUR,		//	==
	M_SYMBOL_PRIORITY_NON_EQUAL = M_SYMBOL_PRIORITY_FOUR,		//	!=

	//四则运算
	M_SYMBOL_PRIORITY_ADD = M_SYMBOL_PRIORITY_FIVE,				//	+
	M_SYMBOL_PRIORITY_SUB = M_SYMBOL_PRIORITY_FIVE,				//	-
	M_SYMBOL_PRIORITY_MULIT = M_SYMBOL_PRIORITY_SIX,			//	*
	M_SYMBOL_PRIORITY_DVI = M_SYMBOL_PRIORITY_SIX,				//	/
	M_SYMBOL_PRIORITY_MOLD = M_SYMBOL_PRIORITY_SIX,				//	%
	//添加点号
	M_SYMBOL_PRIORITY_POINT = M_SYMBOL_PRIORITY_MAX,			// .
	//小括号
	M_SYMBOL_PRIORITY_SMALL_LEFT_PARENTHESES = M_SYMBOL_PRIORITY_NINE,		// （
	M_SYMBOL_PRIORITY_SMALL_RIGHT_PARENTHESES = M_SYMBOL_PRIORITY_NINE,		//	）
	M_SYMBOL_PRIORITY_SMALL_PARENTHESES = M_SYMBOL_PRIORITY_NINE,			//	(）

	//M_SYMBOL_PRIORITY_FUN = M_SYMBOL_PRIORITY_EIGHT,			//function
	M_SYMBOL_PRIORITY_FUN = M_SYMBOL_PRIORITY_TEN,			//function



	//大括号
	//由于语法规定，右大括好只能单独一行，左大括号可以单独一行也可以else加左大括号
	M_SYMBOL_PRIORITY_BIG_LEFT_PARENTHESES = M_SYMBOL_PRIORITY_TEN_ONE, 			// {
	M_SYMBOL_PRIORITY_BIG_RIGHT_PARENTHESES = M_SYMBOL_PRIORITY_TEN_ONE, 		//	}
};

//特殊关键字标识
/*
	应该算是设计缺陷，由于根节点的优先级属性在后续代码中都不会被使用
	并且在以上设计中，if和while都是脚本变量；
	创建语法树时，没有添加多余判断，采用了同一般函数一样的处理方式
	扫描语法树和运行语法树的时候，为了避免频繁的判断，而采用了统一的处理方式
	并且，从本质上将if、while和普通函数都一样没有任何区别，唯一的区别就是对程序流的控制
	所以决定在根节点的优先级属性中设置关键字标识
*/
enum {
	M_KEY_LABEL_INVALID = M_SYMBOL_PRIORITY_NULL,	// 无效关键标识
	M_KEY_LABEL_IF,									// 关键标识if
	M_KEY_LABEL_WHILE,								// while
	M_KEY_LABEL_ELSE,								// else
	M_KEY_LABEL_BIG_LEFT_PARENTHESES,				// {
	M_KEY_LABEL_BIG_RIGHT_PARENTHESES,				// }
	M_KEY_LABEL_TOTAL,								//当前关键标识总数
};